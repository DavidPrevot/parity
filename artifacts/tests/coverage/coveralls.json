{"service_name":"travis-ci","service_job_id":"9540930","git":{"branch":"(detached from 82145d1)","head":{"id":"82145d19d1ac316e5001b5693145b3ba70888df9","author_name":"James Harris","author_email":"james.harris@icecave.com.au","committer_name":"James Harris","committer_email":"james.harris@icecave.com.au","message":"Change abstract comparator to only test comparability once in each direction, updated to archer 1.0.0-alpha.1"},"remotes":[{"name":"origin","url":"git:\/\/github.com\/IcecaveStudios\/parity.git"}]},"run_at":"2013-07-27 03:24:39 +0000","source_files":[{"name":"Icecave\/Parity\/AbstractComparable.php","source":"<?php\nnamespace Icecave\\Parity;\n\nuse Icecave\\Parity\\TypeCheck\\TypeCheck;\n\nabstract class AbstractComparable implements ExtendedComparableInterface\n{\n    public function __construct()\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n    }\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this == $value.\n     *\/\n    public function isEqualTo($value)\n    {\n        TypeCheck::get(__CLASS__)->isEqualTo(func_get_args());\n\n        return $this->compare($value) === 0;\n    }\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this != $value.\n     *\/\n    public function isNotEqualTo($value)\n    {\n        TypeCheck::get(__CLASS__)->isNotEqualTo(func_get_args());\n\n        return $this->compare($value) !== 0;\n    }\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this < $value.\n     *\/\n    public function isLessThan($value)\n    {\n        TypeCheck::get(__CLASS__)->isLessThan(func_get_args());\n\n        return $this->compare($value) < 0;\n    }\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this > $value.\n     *\/\n    public function isGreaterThan($value)\n    {\n        TypeCheck::get(__CLASS__)->isGreaterThan(func_get_args());\n\n        return $this->compare($value) > 0;\n    }\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this <= $value.\n     *\/\n    public function isLessThanOrEqualTo($value)\n    {\n        TypeCheck::get(__CLASS__)->isLessThanOrEqualTo(func_get_args());\n\n        return $this->compare($value) <= 0;\n    }\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this >= $value.\n     *\/\n    public function isGreaterThanOrEqualTo($value)\n    {\n        TypeCheck::get(__CLASS__)->isGreaterThanOrEqualTo(func_get_args());\n\n        return $this->compare($value) >= 0;\n    }\n\n    private $typeCheck;\n}","coverage":[null,null,null,null,null,null,null,null,null,6,6,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null]},{"name":"Icecave\/Parity\/ComparableInterface.php","source":"<?php\nnamespace Icecave\\Parity;\n\ninterface ComparableInterface\n{\n    \/**\n     * Compare this object with another value, yielding a result according to the following table:\n     *\n     * +--------------------+---------------+\n     * | Condition          | Result        |\n     * +--------------------+---------------+\n     * | $this == $value    | $result === 0 |\n     * | $this < $value     | $result < 0   |\n     * | $this > $value     | $result > 0   |\n     * +--------------------+---------------+\n     *\n     * @param mixed $value The value to compare.\n     *\n     * @return integer                          The result of the comparison.\n     * @throws Exception\\NotComparableException Indicates that the implementation does not know how to compare $this to $value.\n     *\/\n    public function compare($value);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Parity\/Comparator\/AbstractComparator.php","source":"<?php\nnamespace Icecave\\Parity\\Comparator;\n\nuse Icecave\\Parity\\ComparableInterface;\nuse Icecave\\Parity\\DelegatingComparableInterface;\nuse Icecave\\Parity\\RestrictedComparableInterface;\nuse Icecave\\Parity\\TypeCheck\\TypeCheck;\n\nabstract class AbstractComparator implements ComparatorInterface\n{\n    public function __construct()\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n    }\n\n    \/**\n     * Compare two values, yielding a result according to the following table:\n     *\n     * +--------------------+---------------+\n     * | Condition          | Result        |\n     * +--------------------+---------------+\n     * | $this == $value    | $result === 0 |\n     * | $this < $value     | $result < 0   |\n     * | $this > $value     | $result > 0   |\n     * +--------------------+---------------+\n     *\n     * @param mixed $lhs The first value to compare.\n     * @param mixed $rhs The second value to compare.\n     *\n     * @return integer The result of the comparison.\n     *\/\n    public function compare($lhs, $rhs)\n    {\n        TypeCheck::get(__CLASS__)->compare(func_get_args());\n\n        if ($this->canCompare($lhs, $rhs)) {\n            if ($lhs instanceof DelegatingComparableInterface) {\n                return $lhs->delegatingCompare($rhs, $this);\n            } elseif ($lhs instanceof ComparableInterface) {\n                return $lhs->compare($rhs);\n            }\n        }\n\n        if ($this->canCompare($rhs, $lhs)) {\n            if ($rhs instanceof DelegatingComparableInterface) {\n                return -$rhs->delegatingCompare($lhs, $this);\n            } elseif ($rhs instanceof ComparableInterface) {\n                return -$rhs->compare($lhs);\n            }\n        }\n\n        return $this->defaultCompare($lhs, $rhs);\n    }\n\n    \/**\n     * @param mixed $lhs\n     * @param mixed $rhs\n     *\n     * @return integer The result of the comparison.\n     *\/\n    abstract public function defaultCompare($lhs, $rhs);\n\n    \/**\n     * @param mixed $lhs\n     * @param mixed $rhs\n     *\n     * @return boolean\n     *\/\n    protected function canCompare($lhs, $rhs)\n    {\n        TypeCheck::get(__CLASS__)->canCompare(func_get_args());\n\n        if ($lhs instanceof RestrictedComparableInterface) {\n            return $lhs->canCompare($rhs);\n        }\n\n        return true;\n    }\n\n    private $typeCheck;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,15,15,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,15,null,15,11,2,9,2,null,7,null,11,9,3,6,3,null,3,null,5,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,15,null,15,10,null,null,11,null,null,null,null]},{"name":"Icecave\/Parity\/Comparator\/Comparator.php","source":"<?php\nnamespace Icecave\\Parity\\Comparator;\n\nuse Icecave\\Parity\\TypeCheck\\TypeCheck;\n\nclass Comparator extends AbstractComparator\n{\n    public function __construct()\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        parent::__construct();\n    }\n\n    \/**\n     * @param mixed $lhs\n     * @param mixed $rhs\n     *\n     * @return integer The result of the comparison.\n     *\/\n    public function defaultCompare($lhs, $rhs)\n    {\n        TypeCheck::get(__CLASS__)->defaultCompare(func_get_args());\n\n        if (gettype($lhs) !== gettype($rhs)) {\n            return strcmp(gettype($lhs), gettype($rhs));\n        }\n\n        if ($lhs < $rhs) {\n            return -1;\n        } elseif ($lhs > $rhs) {\n            return +1;\n        }\n\n        return 0;\n    }\n\n    private $typeCheck;\n}","coverage":[null,null,null,null,null,null,null,null,null,269,null,269,269,null,null,null,null,null,null,null,null,null,269,null,269,268,null,null,1,1,1,1,null,null,1,null,null,null,null]},{"name":"Icecave\/Parity\/Comparator\/ComparatorInterface.php","source":"<?php\nnamespace Icecave\\Parity\\Comparator;\n\ninterface ComparatorInterface\n{\n    \/**\n     * Compare two values, yielding a result according to the following table:\n     *\n     * +--------------------+---------------+\n     * | Condition          | Result        |\n     * +--------------------+---------------+\n     * | $this == $value    | $result === 0 |\n     * | $this < $value     | $result < 0   |\n     * | $this > $value     | $result > 0   |\n     * +--------------------+---------------+\n     *\n     * @param mixed $lhs The first value to compare.\n     * @param mixed $rhs The second value to compare.\n     *\n     * @return integer The result of the comparison.\n     *\/\n    public function compare($lhs, $rhs);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Parity\/Comparator\/DeepComparator.php","source":"<?php\nnamespace Icecave\\Parity\\Comparator;\n\nuse Icecave\\Parity\\TypeCheck\\TypeCheck;\nuse ReflectionObject;\n\nclass DeepComparator extends AbstractComparator\n{\n    public function __construct()\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        parent::__construct();\n    }\n\n    \/**\n     * @param mixed $lhs\n     * @param mixed $rhs\n     *\n     * @return integer The result of the comparison.\n     *\/\n    public function defaultCompare($lhs, $rhs)\n    {\n        TypeCheck::get(__CLASS__)->defaultCompare(func_get_args());\n\n        $this->visitedObjects = array();\n\n        return $this->compareValue($lhs, $rhs);\n    }\n\n    \/**\n     * @param mixed $lhs\n     * @param mixed $rhs\n     *\n     * @return integer The result of the comparison.\n     *\/\n    protected function compareValue($lhs, $rhs)\n    {\n        TypeCheck::get(__CLASS__)->compareValue(func_get_args());\n\n        if (gettype($lhs) !== gettype($rhs)) {\n            return strcmp(gettype($lhs), gettype($rhs));\n        }\n\n        if (is_array($lhs) && is_array($rhs)) {\n            return $this->compareArray($lhs, $rhs);\n        } elseif (is_object($lhs) && is_object($rhs)) {\n            return $this->compareObject($lhs, $rhs);\n        } elseif ($lhs < $rhs) {\n            return -1;\n        } elseif ($lhs > $rhs) {\n            return +1;\n        }\n\n        return 0;\n    }\n\n    \/**\n     * @param array $lhs\n     * @param array $rhs\n     *\n     * @return integer The result of the comparison.\n     *\/\n    protected function compareArray(array $lhs, array $rhs)\n    {\n        TypeCheck::get(__CLASS__)->compareArray(func_get_args());\n\n        $diff = count($lhs) - count($rhs);\n        if ($diff !== 0) {\n            return $diff;\n        }\n\n        reset($lhs);\n        reset($rhs);\n\n        while (true) {\n            $left  = each($lhs);\n            $right = each($rhs);\n\n            if ($left === false && $right === false) {\n                break;\n            }\n\n            $result = $this->compareValue($left['key'], $right['key']);\n            if ($result !== 0) {\n                return $result;\n            }\n\n            $result = $this->compareValue($left['value'], $right['value']);\n            if ($result !== 0) {\n                return $result;\n            }\n        }\n\n        return 0;\n    }\n\n    \/**\n     * @param object $lhs\n     * @param object $rhs\n     *\n     * @return integer The result of the comparison.\n     *\/\n    protected function compareObject($lhs, $rhs)\n    {\n        TypeCheck::get(__CLASS__)->compareObject(func_get_args());\n\n        if ($lhs === $rhs) {\n            return 0;\n        }\n\n        $diff = strcmp(get_class($lhs), get_class($rhs));\n        if ($diff !== 0) {\n            return $diff;\n        }\n\n        return $this->compareArray(\n            $this->objectProperties($lhs),\n            $this->objectProperties($rhs)\n        );\n    }\n\n    \/**\n     * @param object $object\n     *\n     * @return array<string,mixed>\n     *\/\n    protected function objectProperties($object)\n    {\n        TypeCheck::get(__CLASS__)->objectProperties(func_get_args());\n\n        $hashKey = spl_object_hash($object);\n        if (in_array($hashKey, $this->visitedObjects)) {\n            \/\/ To deal with infinite recursion just return the object hash for the properties.\n            return array(get_class($object) => $hashKey);\n        } else {\n            $this->visitedObjects[] = $hashKey;\n        }\n\n        $properties = array();\n        $reflector = new ReflectionObject($object);\n\n        while ($reflector) {\n            foreach ($reflector->getProperties() as $property) {\n                if ($property->isStatic()) {\n                    continue;\n                }\n\n                $key = sprintf(\n                    '%s::%s',\n                    $property->getDeclaringClass()->getName(),\n                    $property->getName()\n                );\n\n                $property->setAccessible(true);\n                $properties[$key] = $property->getValue($object);\n            }\n\n            $reflector = $reflector->getParentClass();\n        }\n\n        return $properties;\n    }\n\n    private $typeCheck;\n    private $visitedObjects;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,294,null,294,294,null,null,null,null,null,null,null,null,null,294,null,294,null,294,null,null,null,null,null,null,null,null,null,null,294,null,294,271,null,null,26,5,26,16,21,17,21,17,null,null,21,null,null,null,null,null,null,null,null,null,null,16,null,16,16,4,null,null,14,14,null,14,14,14,null,14,6,null,null,13,13,1,null,null,13,13,11,null,6,null,6,null,null,null,null,null,null,null,null,null,null,16,null,16,16,null,null,14,14,3,null,null,12,12,12,12,null,null,null,null,null,null,null,null,null,12,null,12,12,null,2,null,12,null,null,12,12,null,12,12,12,5,null,null,12,12,12,12,12,null,12,12,12,null,12,12,null,12,null,null,null,null,null]},{"name":"Icecave\/Parity\/DelegatingComparableInterface.php","source":"<?php\nnamespace Icecave\\Parity;\n\nuse Icecave\\Parity\\Comparator\\ComparatorInterface;\n\ninterface DelegatingComparableInterface\n{\n    \/**\n     * Compare this object with another value, yielding a result according to the following table:\n     *\n     * +--------------------+---------------+\n     * | Condition          | Result        |\n     * +--------------------+---------------+\n     * | $this == $value    | $result === 0 |\n     * | $this < $value     | $result < 0   |\n     * | $this > $value     | $result > 0   |\n     * +--------------------+---------------+\n     *\n     * @param mixed               $value      The value to compare.\n     * @param ComparatorInterface $comparator The comparator being used to perform the comparison.\n     *\n     * @return integer                          The result of the comparison.\n     * @throws Exception\\NotComparableException Indicates that the implementation does not know how to compare $this to $value.\n     *\/\n    public function delegatingCompare($value, ComparatorInterface $comparator);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Parity\/Exception\/NotComparableException.php","source":"<?php\nnamespace Icecave\\Parity\\Exception;\n\nuse Exception;\nuse Icecave\\Parity\\TypeCheck\\TypeCheck;\nuse Icecave\\Repr\\Repr;\nuse LogicException;\n\nclass NotComparableException extends LogicException\n{\n    \/**\n     * @param mixed          $lhs\n     * @param mixed          $rhs\n     * @param Exception|null $previous\n     *\/\n    public function __construct($lhs, $rhs, Exception $previous = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        parent::__construct(\n            sprintf(\n                'Can not compare %s to %s.',\n                Repr::repr($lhs),\n                Repr::repr($rhs)\n            ),\n            0,\n            $previous\n        );\n    }\n\n    private $typeCheck;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,1,1,1,null,1,1,null,null,null]},{"name":"Icecave\/Parity\/ExtendedComparableInterface.php","source":"<?php\nnamespace Icecave\\Parity;\n\ninterface ExtendedComparableInterface extends ComparableInterface\n{\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this == $value.\n     *\/\n    public function isEqualTo($value);\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this != $value.\n     *\/\n    public function isNotEqualTo($value);\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this < $value.\n     *\/\n    public function isLessThan($value);\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this > $value.\n     *\/\n    public function isGreaterThan($value);\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this <= $value.\n     *\/\n    public function isLessThanOrEqualTo($value);\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this >= $value.\n     *\/\n    public function isGreaterThanOrEqualTo($value);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Parity\/ExtendedComparableTrait.php","source":"<?php\nnamespace Icecave\\Parity;\n\ntrait ExtendedComparableTrait\n{\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this == $value.\n     *\/\n    public function isEqualTo($value)\n    {\n        return $this->compare($value) === 0;\n    }\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this != $value.\n     *\/\n    public function isNotEqualTo($value)\n    {\n        return $this->compare($value) !== 0;\n    }\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this < $value.\n     *\/\n    public function isLessThan($value)\n    {\n        return $this->compare($value) < 0;\n    }\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this > $value.\n     *\/\n    public function isGreaterThan($value)\n    {\n        return $this->compare($value) > 0;\n    }\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this <= $value.\n     *\/\n    public function isLessThanOrEqualTo($value)\n    {\n        return $this->compare($value) <= 0;\n    }\n\n    \/**\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this >= $value.\n     *\/\n    public function isGreaterThanOrEqualTo($value)\n    {\n        return $this->compare($value) >= 0;\n    }\n\n    \/**\n     * @see ComparableInterface::compare()\n     *\n     * @param mixed $value The value to compare.\n     *\n     * @return integer|null\n     *\/\n    abstract protected function compare($value);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Parity\/Parity.php","source":"<?php\nnamespace Icecave\\Parity;\n\nuse Icecave\\Parity\\Comparator\\Comparator;\nuse Icecave\\Parity\\Comparator\\DeepComparator;\nuse Icecave\\Parity\\TypeCheck\\TypeCheck;\n\nabstract class Parity\n{\n    \/**\n     * @param mixed   $lhs\n     * @param mixed   $rhs\n     * @param boolean $deep True to do a deep comparasion.\n     *\n     * @return integer The result of the comparison.\n     *\/\n    public static function compare($lhs, $rhs, $deep = true)\n    {\n        TypeCheck::get(__CLASS__)->compare(func_get_args());\n\n        if ($deep) {\n            if (null === self::$deepComparator) {\n                self::$deepComparator = new DeepComparator;\n            }\n\n            return self::$deepComparator->compare($lhs, $rhs);\n        }\n\n        if (null === self::$comparator) {\n            self::$comparator = new Comparator;\n        }\n\n        return self::$comparator->compare($lhs, $rhs);\n    }\n\n    \/**\n     * @param mixed   $lhs  The first value to compare.\n     * @param mixed   $rhs  The second value to compare.\n     * @param boolean $deep True to do a deep comparasion.\n     *\n     * @return boolean True if $lhs == $rhs.\n     *\/\n    public static function isEqualTo($lhs, $rhs, $deep = true)\n    {\n        TypeCheck::get(__CLASS__)->isEqualTo(func_get_args());\n\n        return static::compare($lhs, $rhs, $deep) === 0;\n    }\n\n    \/**\n     * @param mixed   $lhs  The first value to compare.\n     * @param mixed   $rhs  The second value to compare.\n     * @param boolean $deep True to do a deep comparasion.\n     *\n     * @return boolean True if $lhs != $rhs.\n     *\/\n    public static function isNotEqualTo($lhs, $rhs, $deep = true)\n    {\n        TypeCheck::get(__CLASS__)->isNotEqualTo(func_get_args());\n\n        return static::compare($lhs, $rhs, $deep) !== 0;\n    }\n\n    \/**\n     * @param mixed   $lhs  The first value to compare.\n     * @param mixed   $rhs  The second value to compare.\n     * @param boolean $deep True to do a deep comparasion.\n     *\n     * @return boolean True if $lhs < $rhs.\n     *\/\n    public static function isLessThan($lhs, $rhs, $deep = true)\n    {\n        TypeCheck::get(__CLASS__)->isLessThan(func_get_args());\n\n        return static::compare($lhs, $rhs, $deep) < 0;\n    }\n\n    \/**\n     * @param mixed   $lhs  The first value to compare.\n     * @param mixed   $rhs  The second value to compare.\n     * @param boolean $deep True to do a deep comparasion.\n     *\n     * @return boolean True if $lhs > $rhs.\n     *\/\n    public static function isGreaterThan($lhs, $rhs, $deep = true)\n    {\n        TypeCheck::get(__CLASS__)->isGreaterThan(func_get_args());\n\n        return static::compare($lhs, $rhs, $deep) > 0;\n    }\n\n    \/**\n     * @param mixed   $lhs  The first value to compare.\n     * @param mixed   $rhs  The second value to compare.\n     * @param boolean $deep True to do a deep comparasion.\n     *\n     * @return boolean True if $lhs <= $rhs.\n     *\/\n    public static function isLessThanOrEqualTo($lhs, $rhs, $deep = true)\n    {\n        TypeCheck::get(__CLASS__)->isLessThanOrEqualTo(func_get_args());\n\n        return static::compare($lhs, $rhs, $deep) <= 0;\n    }\n\n    \/**\n     * @param mixed   $lhs  The first value to compare.\n     * @param mixed   $rhs  The second value to compare.\n     * @param boolean $deep True to do a deep comparasion.\n     *\n     * @return boolean True if $lhs >= $rhs.\n     *\/\n    public static function isGreaterThanOrEqualTo($lhs, $rhs, $deep = true)\n    {\n        TypeCheck::get(__CLASS__)->isGreaterThanOrEqualTo(func_get_args());\n\n        return static::compare($lhs, $rhs, $deep) >= 0;\n    }\n\n    private static $comparator;\n    private static $deepComparator;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,12,null,12,6,1,1,null,6,null,null,6,1,1,null,6,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null]},{"name":"Icecave\/Parity\/RestrictedComparableInterface.php","source":"<?php\nnamespace Icecave\\Parity;\n\ninterface RestrictedComparableInterface\n{\n    \/**\n     * Check if $this is able to be compared to another value.\n     *\n     * A return value of false indicates that calling $this->compare($value)\n     * will throw an exception.\n     *\n     * @param mixed $value The value to compare.\n     *\n     * @return boolean True if $this can be compared to $value.\n     *\/\n    public function canCompare($value);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}